{"ast":null,"code":"import { randomBytes } from 'crypto';\nimport { isBlob } from './is.js';\nconst carriage = '\\r\\n';\nconst dashes = '-'.repeat(2);\nconst carriageLength = Buffer.byteLength(carriage);\n/**\n * @param {string} boundary\n */\n\nconst getFooter = boundary => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;\n/**\n * @param {string} boundary\n * @param {string} name\n * @param {*} field\n *\n * @return {string}\n */\n\n\nfunction getHeader(boundary, name, field) {\n  let header = '';\n  header += `${dashes}${boundary}${carriage}`;\n  header += `Content-Disposition: form-data; name=\"${name}\"`;\n\n  if (isBlob(field)) {\n    header += `; filename=\"${field.name}\"${carriage}`;\n    header += `Content-Type: ${field.type || 'application/octet-stream'}`;\n  }\n\n  return `${header}${carriage.repeat(2)}`;\n}\n/**\n * @return {string}\n */\n\n\nexport const getBoundary = () => randomBytes(8).toString('hex');\n/**\n * @param {FormData} form\n * @param {string} boundary\n */\n\nexport async function* formDataIterator(form, boundary) {\n  for (const [name, value] of form) {\n    yield getHeader(boundary, name, value);\n\n    if (isBlob(value)) {\n      yield* value.stream();\n    } else {\n      yield value;\n    }\n\n    yield carriage;\n  }\n\n  yield getFooter(boundary);\n}\n/**\n * @param {FormData} form\n * @param {string} boundary\n */\n\nexport function getFormDataLength(form, boundary) {\n  let length = 0;\n\n  for (const [name, value] of form) {\n    length += Buffer.byteLength(getHeader(boundary, name, value));\n    length += isBlob(value) ? value.size : Buffer.byteLength(String(value));\n    length += carriageLength;\n  }\n\n  length += Buffer.byteLength(getFooter(boundary));\n  return length;\n}","map":null,"metadata":{},"sourceType":"module"}