{"ast":null,"code":"/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\nimport Stream, { PassThrough } from 'stream';\nimport { types } from 'util';\nimport Blob from 'fetch-blob';\nimport { FetchError } from './errors/fetch-error.js';\nimport { FetchBaseError } from './errors/base.js';\nimport { formDataIterator, getBoundary, getFormDataLength } from './utils/form-data.js';\nimport { isBlob, isURLSearchParameters, isFormData } from './utils/is.js';\nconst INTERNALS = Symbol('Body internals');\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\n\nexport default class Body {\n  constructor(body, {\n    size = 0\n  } = {}) {\n    let boundary = null;\n\n    if (body === null) {\n      // Body is undefined or null\n      body = null;\n    } else if (isURLSearchParameters(body)) {\n      // Body is a URLSearchParams\n      body = Buffer.from(body.toString());\n    } else if (isBlob(body)) {// Body is blob\n    } else if (Buffer.isBuffer(body)) {// Body is Buffer\n    } else if (types.isAnyArrayBuffer(body)) {\n      // Body is ArrayBuffer\n      body = Buffer.from(body);\n    } else if (ArrayBuffer.isView(body)) {\n      // Body is ArrayBufferView\n      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n    } else if (body instanceof Stream) {// Body is stream\n    } else if (isFormData(body)) {\n      // Body is an instance of formdata-node\n      boundary = `NodeFetchFormDataBoundary${getBoundary()}`;\n      body = Stream.Readable.from(formDataIterator(body, boundary));\n    } else {\n      // None of the above\n      // coerce to string then buffer\n      body = Buffer.from(String(body));\n    }\n\n    this[INTERNALS] = {\n      body,\n      boundary,\n      disturbed: false,\n      error: null\n    };\n    this.size = size;\n\n    if (body instanceof Stream) {\n      body.on('error', error_ => {\n        const error = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);\n        this[INTERNALS].error = error;\n      });\n    }\n  }\n\n  get body() {\n    return this[INTERNALS].body;\n  }\n\n  get bodyUsed() {\n    return this[INTERNALS].disturbed;\n  }\n  /**\n   * Decode response as ArrayBuffer\n   *\n   * @return  Promise\n   */\n\n\n  async arrayBuffer() {\n    const {\n      buffer,\n      byteOffset,\n      byteLength\n    } = await consumeBody(this);\n    return buffer.slice(byteOffset, byteOffset + byteLength);\n  }\n  /**\n   * Return raw response as Blob\n   *\n   * @return Promise\n   */\n\n\n  async blob() {\n    const ct = this.headers && this.headers.get('content-type') || this[INTERNALS].body && this[INTERNALS].body.type || '';\n    const buf = await this.buffer();\n    return new Blob([buf], {\n      type: ct\n    });\n  }\n  /**\n   * Decode response as json\n   *\n   * @return  Promise\n   */\n\n\n  async json() {\n    const buffer = await consumeBody(this);\n    return JSON.parse(buffer.toString());\n  }\n  /**\n   * Decode response as text\n   *\n   * @return  Promise\n   */\n\n\n  async text() {\n    const buffer = await consumeBody(this);\n    return buffer.toString();\n  }\n  /**\n   * Decode response as buffer (non-spec api)\n   *\n   * @return  Promise\n   */\n\n\n  buffer() {\n    return consumeBody(this);\n  }\n\n} // In browsers, all properties are enumerable.\n\nObject.defineProperties(Body.prototype, {\n  body: {\n    enumerable: true\n  },\n  bodyUsed: {\n    enumerable: true\n  },\n  arrayBuffer: {\n    enumerable: true\n  },\n  blob: {\n    enumerable: true\n  },\n  json: {\n    enumerable: true\n  },\n  text: {\n    enumerable: true\n  }\n});\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\n\nasync function consumeBody(data) {\n  if (data[INTERNALS].disturbed) {\n    throw new TypeError(`body used already for: ${data.url}`);\n  }\n\n  data[INTERNALS].disturbed = true;\n\n  if (data[INTERNALS].error) {\n    throw data[INTERNALS].error;\n  }\n\n  let {\n    body\n  } = data; // Body is null\n\n  if (body === null) {\n    return Buffer.alloc(0);\n  } // Body is blob\n\n\n  if (isBlob(body)) {\n    body = Stream.Readable.from(body.stream());\n  } // Body is buffer\n\n\n  if (Buffer.isBuffer(body)) {\n    return body;\n  }\n  /* c8 ignore next 3 */\n\n\n  if (!(body instanceof Stream)) {\n    return Buffer.alloc(0);\n  } // Body is stream\n  // get ready to actually consume the body\n\n\n  const accum = [];\n  let accumBytes = 0;\n\n  try {\n    for await (const chunk of body) {\n      if (data.size > 0 && accumBytes + chunk.length > data.size) {\n        const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');\n        body.destroy(error);\n        throw error;\n      }\n\n      accumBytes += chunk.length;\n      accum.push(chunk);\n    }\n  } catch (error) {\n    const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);\n    throw error_;\n  }\n\n  if (body.readableEnded === true || body._readableState.ended === true) {\n    try {\n      if (accum.every(c => typeof c === 'string')) {\n        return Buffer.from(accum.join(''));\n      }\n\n      return Buffer.concat(accum, accumBytes);\n    } catch (error) {\n      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);\n    }\n  } else {\n    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n  }\n}\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\n\n\nexport const clone = (instance, highWaterMark) => {\n  let p1;\n  let p2;\n  let {\n    body\n  } = instance; // Don't allow cloning a used body\n\n  if (instance.bodyUsed) {\n    throw new Error('cannot clone body after it is used');\n  } // Check that body is a stream and not form-data object\n  // note: we can't clone the form-data object without having it as a dependency\n\n\n  if (body instanceof Stream && typeof body.getBoundary !== 'function') {\n    // Tee instance body\n    p1 = new PassThrough({\n      highWaterMark\n    });\n    p2 = new PassThrough({\n      highWaterMark\n    });\n    body.pipe(p1);\n    body.pipe(p2); // Set instance body to teed body and return the other teed body\n\n    instance[INTERNALS].body = p1;\n    body = p2;\n  }\n\n  return body;\n};\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\n\nexport const extractContentType = (body, request) => {\n  // Body is null or undefined\n  if (body === null) {\n    return null;\n  } // Body is string\n\n\n  if (typeof body === 'string') {\n    return 'text/plain;charset=UTF-8';\n  } // Body is a URLSearchParams\n\n\n  if (isURLSearchParameters(body)) {\n    return 'application/x-www-form-urlencoded;charset=UTF-8';\n  } // Body is blob\n\n\n  if (isBlob(body)) {\n    return body.type || null;\n  } // Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n\n\n  if (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n    return null;\n  } // Detect form data input from form-data module\n\n\n  if (body && typeof body.getBoundary === 'function') {\n    return `multipart/form-data;boundary=${body.getBoundary()}`;\n  }\n\n  if (isFormData(body)) {\n    return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n  } // Body is stream - can't really do much about this\n\n\n  if (body instanceof Stream) {\n    return null;\n  } // Body constructor defaults other things to string\n\n\n  return 'text/plain;charset=UTF-8';\n};\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\n\nexport const getTotalBytes = request => {\n  const {\n    body\n  } = request; // Body is null or undefined\n\n  if (body === null) {\n    return 0;\n  } // Body is Blob\n\n\n  if (isBlob(body)) {\n    return body.size;\n  } // Body is Buffer\n\n\n  if (Buffer.isBuffer(body)) {\n    return body.length;\n  } // Detect form data input from form-data module\n\n\n  if (body && typeof body.getLengthSync === 'function') {\n    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n  } // Body is a spec-compliant form-data\n\n\n  if (isFormData(body)) {\n    return getFormDataLength(request[INTERNALS].boundary);\n  } // Body is stream\n\n\n  return null;\n};\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {void}\n */\n\nexport const writeToStream = (dest, {\n  body\n}) => {\n  if (body === null) {\n    // Body is null\n    dest.end();\n  } else if (isBlob(body)) {\n    // Body is Blob\n    Stream.Readable.from(body.stream()).pipe(dest);\n  } else if (Buffer.isBuffer(body)) {\n    // Body is buffer\n    dest.write(body);\n    dest.end();\n  } else {\n    // Body is stream\n    body.pipe(dest);\n  }\n};","map":null,"metadata":{},"sourceType":"module"}